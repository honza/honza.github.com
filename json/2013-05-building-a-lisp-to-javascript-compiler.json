{
    "reading_time": "10 minutes", 
    "month": "05", 
    "year": "2013", 
    "date": "May 13, 2013", 
    "slug": "building-a-lisp-to-javascript-compiler", 
    "contents": "<div class=\"section\" id=\"building-a-lisp-to-javascript-compiler\">\n<h1>Building a Lisp to Javascript&nbsp;compiler</h1>\n<p>In this post, I&#8217;m going to show you how I made a Lisp to Javascript compiler. I\nreally enjoy programming in Clojure but have often thought that the <span class=\"caps\">JVM</span> isn&#8217;t\nalways the best platform for scripts due to the slow <span class=\"caps\">JVM</span> start-up. So, I\ndecided to implement a simple version of Clojure that compiles to Javascript\nand can be run on top of&nbsp;nodejs.</p>\n<p>Compilers are notoriously hard to understand and therefore make for great\nmind-bending exercises.  Exactly my idea of weekend&nbsp;fun.</p>\n<div class=\"section\" id=\"what-we-are-going-to-do\">\n<h2>What we are going to&nbsp;do</h2>\n<p>There are tons of Lisp to Javascript compilers out there.  What makes mine\nspecial?  I&#8217;m using a <span class=\"caps\">PEG</span> grammar to parse the source code.  Once it&#8217;s parsed,\nI turn the result into a <a class=\"reference external\" href=\"https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\">Parser <span class=\"caps\">API</span></a> compatible <span class=\"caps\">AST</span>.  The <span class=\"caps\">AST</span> is then passed\nto <a class=\"reference external\" href=\"https://github.com/Constellation/escodegen\">escodegen</a> which turns it into well-formatted&nbsp;Javascript.</p>\n<p>This is great because I don&#8217;t have to worry about the particulars of Javascript\nsyntax.  Escodegen takes care of inserting semicolons where appropriate, etc.\nand everything looks clean and consistent.  It&#8217;s nice because the parsing is\ndecoupled from the source code emission.  You can completely remove the\nJavascript generation part and use some other software to do&nbsp;that.</p>\n</div>\n<div class=\"section\" id=\"lisp-basics\">\n<h2>Lisp&nbsp;basics</h2>\n<p>If you are familiar with Lisp, you can skip this&nbsp;section.</p>\n<p>Lisp source code is made up of s-expressions.  An s-expression is a list whose\nfirst element is a function and the rest are the arguments to that&nbsp;function.</p>\n<div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"nf\">greet</span> <span class=\"s\">&quot;honza&quot;</span><span class=\"p\">)</span>\n</pre></div>\n<p>This is a list with two items.  <tt class=\"docutils literal\">greet</tt> is the name of the function and\n<tt class=\"docutils literal\">&#8220;honza&#8221;</tt> is the argument.  In other languages, this might be represented as\n<tt class=\"docutils literal\"><span class=\"pre\">greet(&#8220;honza&#8221;)</span></tt>.</p>\n<p>Lisp uses s-expressions for everything, including function definitions, if\nstatements, assignments, binary expressions,&nbsp;etc.</p>\n<div class=\"highlight\"><pre><span class=\"p\">(</span><span class=\"k\">def </span><span class=\"nb\">name </span><span class=\"s\">&quot;honza&quot;</span><span class=\"p\">)</span> <span class=\"c1\">;; define a variable &quot;name&quot; and assign &quot;honza&quot; to it</span>\n<span class=\"p\">(</span><span class=\"nb\">+ </span><span class=\"mi\">1</span> <span class=\"mi\">2</span><span class=\"p\">)</span>            <span class=\"c1\">;; add 1 and 2 and return the result</span>\n\n<span class=\"c1\">;; If the name variable is equal to &quot;honza&quot;, print &quot;hey honza&quot;, otherwise,</span>\n<span class=\"c1\">;; just print &quot;hey stranger&quot;.</span>\n\n<span class=\"p\">(</span><span class=\"k\">if </span><span class=\"p\">(</span><span class=\"nb\">= name </span><span class=\"s\">&quot;honza&quot;</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"nb\">print </span><span class=\"s\">&quot;hey honza&quot;</span><span class=\"p\">)</span>\n  <span class=\"p\">(</span><span class=\"nb\">print </span><span class=\"s\">&quot;hey stranger&quot;</span><span class=\"p\">))</span>\n\n<span class=\"c1\">;; Function definition; it takes one parameter called &quot;name&quot;.</span>\n\n<span class=\"p\">(</span><span class=\"k\">def </span><span class=\"nv\">greet</span>\n  <span class=\"p\">(</span><span class=\"k\">fn </span><span class=\"p\">[</span><span class=\"nv\">name</span><span class=\"p\">]</span>\n    <span class=\"p\">(</span><span class=\"nb\">println </span><span class=\"s\">&quot;hello&quot;</span> <span class=\"nv\">name</span><span class=\"p\">)))</span>\n</pre></div>\n<p>In Lisp, a function body can have multiple s-expression but only the last one\nis returned.  There is no <tt class=\"docutils literal\">return</tt> keyword in Lisp.  Binary operators and\nthings like the <tt class=\"docutils literal\">if</tt> keyword are actually functions that return&nbsp;values.</p>\n</div>\n<div class=\"section\" id=\"the-mighty-peg\">\n<h2>The mighty&nbsp;<span class=\"caps\">PEG</span></h2>\n<p>Every <span class=\"caps\">PEG</span> grammar starts with the <tt class=\"docutils literal\">program</tt> directive.  This is where the\nparser will start&nbsp;parsing.</p>\n<pre class=\"literal-block\">\nprogram\n  = s:sexp+ &quot;\\n&quot;*  { return {\n      type: 'Program',\n      body: s\n  };}\n</pre>\n<p>A Lisp program consists of one or more s-expressions, optionally followed by a\nnewline.  The list of one or more s-expressions is stored in the variable\n<tt class=\"docutils literal\">s</tt>.  We then return a Javascript object with two properties: <tt class=\"docutils literal\">type</tt> and\n<tt class=\"docutils literal\">body</tt>.  Since we are at the top level, we return it as a type of\n<tt class=\"docutils literal\">Program</tt>, and our body will be made up of the matched s-expressions.  The\nsyntax is a little weird at first but you get used to it.  Fairly simple&nbsp;stuff.</p>\n<p>If you tried to compile this grammar into a parser, it would fail because we\ndidn&#8217;t tell it what an s-expression looks&nbsp;like.</p>\n<pre class=\"literal-block\">\nsexp\n  = _ a:atom _ { return a; }\n  / _ l:list _ { return l; }\n  / _ v:vector _ { return v; }\n  / _ o:object _ { return o; }\n</pre>\n<p><span class=\"caps\">OK</span>, so an s-expression is either an atom, a list, a vector or an object.  Each\nof these can be preceded and followed by any amount of whitespace.  Cool,\nthat&#8217;s simple enough.  Except now we have to define what all those things&nbsp;are.</p>\n<p>Let&#8217;s start with the&nbsp;atom:</p>\n<pre class=\"literal-block\">\natom\n  = d:[0-9]+ _ { return {type: 'Literal', value: numberify(d)}; }\n  / '&quot;' d:(!'&quot;' sourcechar)* '&quot;' _ { return {type: 'Literal', value: makeStr(d) }}\n  / s:[-+/\\*_&lt;&gt;=a-zA-Z\\.!]+ _ { return {type: 'Identifier', name: s.join(&quot;&quot;)};}\n</pre>\n<p>So, an atom can be a list of one or more digits, a string or a valid\nidentifier.  In the digit directive, you will notice that we are assigning the\nnumber to the <tt class=\"docutils literal\">d</tt> variable.  This will contain a list of all of the matched\nnumbers.  We then concatenate them and parse them into an integer.  That&#8217;s what\nthe <tt class=\"docutils literal\">numberify</tt> function does.  A number or a string is a literal value so we\nreturn it as such.  An identifier is a variable name, so we return it as such,&nbsp;too.</p>\n<p>Next up, vectors and&nbsp;objects:</p>\n<pre class=\"literal-block\">\nvector\n  = &quot;[]&quot; { return {type: 'ArrayExpression', elements: []}; }\n  / _ &quot;[&quot; _ a:atom+ _ &quot;]&quot; _ { return {type: 'ArrayExpression', elements: a};}\n  / _ &quot;[&quot; _ o:object+ _ &quot;]&quot; _ { return {type: 'ArrayExpression', elements: o};}\n\nobject\n  = &quot;{}&quot; { return {type: 'ObjectExpression', properties: []}; }\n  / _ &quot;{&quot; _ a:atom+ _ &quot;}&quot; _ { return makeObject(a); }\n</pre>\n<p>Continuing in the same vein, a vector is either an empty array, an array with\nat least one atom in it, or an array with at least one object in&nbsp;it.</p>\n<p>The <tt class=\"docutils literal\">makeObject</tt> function will take a pair by pair from the array and take\nthe first item in the pair and turn it into an object key and set as its value\nto the second item in the pair.  If the number of elements in the array isn&#8217;t\ndivisible by 2, it will yell at&nbsp;you.</p>\n<p>Next up, lists.  Now, lists are special because the first item is the name of a\nfunction.  This gives us the opportunity to define some built-in functions that\nwould otherwise be really tricky to&nbsp;define.</p>\n<pre class=\"literal-block\">\nlist\n  = &quot;()&quot; { return []; }\n  /  _ &quot;(&quot; _ s:sexp+ _ &quot;)&quot; _ {\n    if (first(s).name === 'def') {\n      return {\n        type: 'VariableDeclaration',\n        declarations: [{\n          type: 'VariableDeclarator',\n          id: s[1],\n          init: s[2].expression? s[2].expression : s[2]\n        }],\n        kind: 'var'\n      };\n    }\n\n    if (first(s).name === 'fn') {\n      return {\n        type: 'FunctionExpression',\n        id: null,\n        params: s[1].elements ? s[1].elements : s[1],\n        body: {\n          type: 'BlockStatement',\n          body: init(rest(rest((s)))).concat(returnStatement(last(rest(s))))\n        }\n      };\n    }\n\n    if (Object.keys(builtins).indexOf(first(s).name) &gt; -1) {\n      return builtins[first(s).name](rest(s));\n    }\n\n    return processCallExpression(s);\n\n  }\n</pre>\n<p><span class=\"caps\">OK</span>, there is quite a bit here, so let&#8217;s step through it.  A list can&nbsp;be</p>\n<ul class=\"simple\">\n<li>an empty&nbsp;list</li>\n<li>a list of at least one&nbsp;s-expression</li>\n</ul>\n<p>If it&#8217;s an empty list, we just return an empty array.  If it&#8217;s a list of\ns-expressions, we check for other things.  We look at the first element and see\nwhat its name is.  It can be&nbsp;either:</p>\n<ul class=\"simple\">\n<li><tt class=\"docutils literal\">def</tt> - variable&nbsp;declaration</li>\n<li><tt class=\"docutils literal\">fn</tt> - an anonymous&nbsp;function</li>\n<li>a built-in function (<tt class=\"docutils literal\">if</tt>, <tt class=\"docutils literal\">+</tt>, <tt class=\"docutils literal\">list</tt>,&nbsp;etc.)</li>\n<li>other function (user&nbsp;defined)</li>\n</ul>\n<p>The only thing left is the definition of&nbsp;whitespace</p>\n<pre class=\"literal-block\">\n_\n  = [\\n, ]*\n</pre>\n<p>Zero or more of the following characters: newline, comma and&nbsp;space.</p>\n</div>\n<div class=\"section\" id=\"obstacles\">\n<h2>Obstacles</h2>\n<p>When converting the parsed source code to the Parser <span class=\"caps\">API</span> tree, I hit a few\nobstacles.  It turns out that Lisp and Javascript don&#8217;t map perfectly to each\nother and therefore some post-processing is&nbsp;needed.</p>\n<div class=\"section\" id=\"statement-vs-expression\">\n<h3>Statement vs&nbsp;expression</h3>\n<p>In Lisp, everything is an expression.  In Javascript, there are both\nexpressions and statements.  The hardest part is the fact that a function call\ncan be both a statement and an expression depending on how it&#8217;s used.  So you\ncan&#8217;t represent it the same way every&nbsp;time.</p>\n<p>I wrote a function that takes a list which represents an s-expression (the\nfirst element is a function call, the rest are the&nbsp;parameters).</p>\n<div class=\"highlight\"><pre><span class=\"kd\">function</span> <span class=\"nx\">processCallExpression</span><span class=\"p\">(</span><span class=\"nx\">s</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"kd\">var</span> <span class=\"nx\">callee</span> <span class=\"o\">=</span> <span class=\"nx\">first</span><span class=\"p\">(</span><span class=\"nx\">s</span><span class=\"p\">),</span>\n      <span class=\"nx\">args</span> <span class=\"o\">=</span> <span class=\"nx\">rest</span><span class=\"p\">(</span><span class=\"nx\">s</span><span class=\"p\">)</span>\n\n  <span class=\"nx\">args</span> <span class=\"o\">=</span> <span class=\"nx\">map</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">s</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">expression</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">expression</span><span class=\"p\">.</span><span class=\"nx\">type</span> <span class=\"o\">===</span> <span class=\"s1\">&#39;CallExpression&#39;</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">return</span> <span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">expression</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n      <span class=\"k\">return</span> <span class=\"nx\">s</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">},</span> <span class=\"nx\">args</span><span class=\"p\">);</span>\n\n  <span class=\"k\">return</span> <span class=\"p\">{</span>\n    <span class=\"nx\">type</span><span class=\"o\">:</span> <span class=\"s1\">&#39;ExpressionStatement&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">expression</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">type</span><span class=\"o\">:</span> <span class=\"s1\">&#39;CallExpression&#39;</span><span class=\"p\">,</span>\n      <span class=\"nx\">callee</span><span class=\"o\">:</span> <span class=\"nx\">callee</span><span class=\"p\">,</span>\n      <span class=\"s1\">&#39;arguments&#39;</span><span class=\"o\">:</span> <span class=\"nx\">args</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n\n<span class=\"p\">}</span>\n</pre></div>\n<p>This will check if any of the arguments passed to the function are also\nfunction calls.  If it&#8217;s a nested function call, it&#8217;s placed in the <span class=\"caps\">AST</span> as a\n<tt class=\"docutils literal\">CallExpression</tt>, otherwise it&#8217;s a <tt class=\"docutils literal\">CallExpression</tt> inside a\n<tt class=\"docutils literal\">ExpressionStatement</tt>.  The <span class=\"caps\">PEG</span> parser can&#8217;t detect this because it&#8217;s context\nfree - each node only knows about&nbsp;itself.</p>\n</div>\n<div class=\"section\" id=\"implicit-return\">\n<h3>Implicit&nbsp;return</h3>\n<p>In Lisp, the last s-expression in a function&#8217;s body is implicitly returned.\nYou don&#8217;t need to denote this with a return statement, it&#8217;s built-in.  Again,\nwe need to do some more processing.  If we are processing a function\ndeclaration, we need to check its body and wrap the last expression in a\n<tt class=\"docutils literal\">ReturnStatement</tt>.</p>\n</div>\n<div class=\"section\" id=\"if-is-an-expression-in-lisp\">\n<h3>If is an expression in&nbsp;Lisp</h3>\n<p>The if statement in Lisp is an expression, just like a function call or\nanything else.  This means that the expression in any of the two branches is\neffectively returned to the caller.  This means that we need to add an extra\nwrapper around the statement and wrap each of the branch-expressions in a\nreturn&nbsp;statement.</p>\n<p>Like&nbsp;this:</p>\n<div class=\"highlight\"><pre><span class=\"c1\">// this</span>\n\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">n</span> <span class=\"o\">===</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"s2\">&quot;it&#39;s zero&quot;</span><span class=\"p\">;</span>\n<span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"s2\">&quot;it&#39;s more than zero&quot;</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// becomes</span>\n\n<span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">n</span> <span class=\"o\">===</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"s2\">&quot;it&#39;s zero&quot;</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"s2\">&quot;it&#39;s more than zero&quot;</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">})();</span>\n</pre></div>\n</div>\n</div>\n<div class=\"section\" id=\"standard-library\">\n<h2>Standard&nbsp;library</h2>\n<p>A lisp would be no fun without some fun functional programming functions.  I\nhave started working on a standard library for our lisp.  It lives in a file\ncalled <tt class=\"docutils literal\">lib.js</tt>.  This file includes functions that are accessible from any\nprogram that you&nbsp;write.</p>\n<p>For&nbsp;example:</p>\n<div class=\"highlight\"><pre><span class=\"kd\">function</span> <span class=\"nx\">nth</span><span class=\"p\">(</span><span class=\"nx\">list</span><span class=\"p\">,</span> <span class=\"nx\">n</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">list</span><span class=\"p\">.</span><span class=\"nx\">length</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">list</span><span class=\"p\">.</span><span class=\"nx\">length</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"o\">&lt;</span> <span class=\"nx\">n</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">return</span> <span class=\"nx\">list</span><span class=\"p\">[</span><span class=\"nx\">n</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">first</span><span class=\"p\">(</span><span class=\"nx\">list</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">nth</span><span class=\"p\">(</span><span class=\"nx\">list</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</pre></div>\n<p>And much&nbsp;more.</p>\n</div>\n<div class=\"section\" id=\"putting-it-all-together\">\n<h2>Putting it all&nbsp;together</h2>\n<p>Here is how it all comes&nbsp;together:</p>\n<ol class=\"arabic simple\">\n<li>Use peg.js to compile the grammar into a&nbsp;parser</li>\n<li>Take the parser and append to it the compiler&nbsp;program</li>\n</ol>\n<p>The compiler program is the command line utility that decides how your program\nshould be compiled, it parsers <span class=\"caps\">CLI</span> flags, etc.  It can return the <span class=\"caps\">AST</span> instead\nof Javascript, it can uglify the resulting Javascript,&nbsp;etc.</p>\n<p>You can use the result like&nbsp;so</p>\n<pre class=\"literal-block\">\n$ ./inertia sample.clj\n</pre>\n<p>And it will print the resulting Javascript to stdout.  What the compiler\nprogram will also do is prepend the compiled Javascript with the standard\nlibrary.  It simply reads the standard library code from the <tt class=\"docutils literal\">lib.js</tt> file\nand prepends&nbsp;it.</p>\n</div>\n<div class=\"section\" id=\"conclusion\">\n<h2>Conclusion</h2>\n<p>This has certainly been a fun exercise for me.  You can check out the finished\nproduct on <a class=\"reference external\" href=\"https://github.com/honza/inertia\">GitHub</a>.</p>\n</div>\n</div>\n", 
    "date_iso": "2013-05-13", 
    "title": "Building a Lisp to Javascript compiler", 
    "url": "/2013/05/building-a-lisp-to-javascript-compiler", 
    "day": "13", 
    "categories": [
        {
            "name": "compilers", 
            "slug": "compilers"
        }, 
        {
            "name": "lisp", 
            "slug": "lisp"
        }, 
        {
            "name": "javascript", 
            "slug": "javascript"
        }
    ]
}