{
    "reading_time": "4 minutes", 
    "month": "09", 
    "year": "2011", 
    "date": "September 20, 2011", 
    "slug": "using-chef-with-small-django-apps", 
    "contents": "<div class=\"section\" id=\"using-chef-with-small-django-apps\">\n<h1>Using Chef with small Django&nbsp;apps</h1>\n<p>This year at <a class=\"reference external\" href=\"http://djangocon.us\">DjangoCon</a>, it seemed like everybody was talking about automatic\ndeployments and namely <a class=\"reference external\" href=\"http://www.opscode.com/chef/\">Chef</a>. After coming home from the conference, I spent\na considerable amount of time learning chef and thinking about how it can be\nbest used with small to medium size Django apps. In this post, I will walk you\nthrough how Chef works and how it can help you make awesome web&nbsp;apps.</p>\n<p>When I say small apps, I mean single-server deployments. This means that your\nweb server, your database, memcached, rabbitmq, etc is installed on a single\nUbuntu <span class=\"caps\">VM</span>. When learning Chef, I found that most of the available tutorials\nfocus on multi-server setups and are too complex for ordinary&nbsp;apps.</p>\n<p>Unfortunately, Chef is written in Ruby and it can be a little tricky to debug\nsince all the tracebacks are meaningless to a Python developer. However, don&#8217;t\ndespair, you can usually tell pretty quickly what&#8217;s going on. To test your\ndeployment, we will be using <a class=\"reference external\" href=\"http://vagrantup.com\">Vagrant</a> which is an awesome tool for running\nvirtual machines on your development&nbsp;machine.</p>\n<div class=\"section\" id=\"what-we-will-install\">\n<h2>What we will&nbsp;install</h2>\n<p>Our Django application will be deployed using the&nbsp;following:</p>\n<ul class=\"simple\">\n<li>nginx</li>\n<li>gunicorn</li>\n<li>postgresql</li>\n<li>memcached</li>\n<li>rabbitmq</li>\n<li>git</li>\n</ul>\n<p>Your development machine will need to have <a class=\"reference external\" href=\"http://docs.fabfile.org/en/1.2.2/index.html\">Fabric</a>&nbsp;installed.</p>\n</div>\n<div class=\"section\" id=\"how-chef-works\">\n<h2>How Chef&nbsp;works</h2>\n<p>Chef is a tool that is installed on your server. You give it a bunch\nconfiguration files and tell it to provision server with the necessary packages\nand settings. This means that our automatic deployment will have to parts: Chef\nconfiguration files for the sever, and several Fabric tasks to install Chef\nremotely and start the provisioning&nbsp;process.</p>\n<p>So, to configure Chef, we will create a <em>deploy</em> directory inside our project&#8217;s\nrepository. I like to keep the following&nbsp;structure:</p>\n<div class=\"highlight\"><pre><span class=\"gp\">$</span> ls -a\n<span class=\"go\">.git coolapp docs deploy <span class=\"caps\">README</span>.md Vagrantfile fabfile.py</span>\n</pre></div>\n<p>&#8230; where <em>coolapp</em> is your Django project. We will focus on the <em>deploy</em>\ndirectory and the <em>fabfile</em>. Chef is a cook how prepares your server for\ndinner. So, Chef needs some cookbooks and recipes. Each cookbook is a directory\nthat contains various configuration files for a specific application that you\nwant installed. So for example, you will have a <em>PostgreSQL cookbook</em> and a\n<em>nginx cookbook</em>. The  deploy directory will contain a directory called\n<em>cookbooks</em> which will contain all other cookbooks. Now, the good news is that\nyou don&#8217;t have to make the cookbooks yourself. <a class=\"reference external\" href=\"http://www.opscode.com\">Opscode</a>, the company behind\nChef, maintains a large selection of cookbooks on <a class=\"reference external\" href=\"https://github.com/opscode/cookbooks\">Github</a>. You can copy and\npaste the cookbooks you need for you project. We will need the&nbsp;following:</p>\n<ul class=\"simple\">\n<li>build-essential (for building from&nbsp;source)</li>\n<li>erlang (rabbitmq depends on&nbsp;this)</li>\n<li>git</li>\n<li>memcached</li>\n<li>nginx</li>\n<li>postgresql</li>\n<li>python (for virtualenv and python header&nbsp;files)</li>\n<li>rabbitmq</li>\n</ul>\n</div>\n<div class=\"section\" id=\"cookbooks\">\n<h2>Cookbooks</h2>\n<p>Each cookbook contains a <em>recipes</em> directory. Each recipe tells Chef how this\nparticular application is to be installed and configured. For example, it will\ntell nginx to create an entry in <em>sites-available</em> and <em>sites-enabled</em>. Or, it\nwill restart PostreSQL when it&#8217;s done being&nbsp;installed.</p>\n<p>There is also a <em>files</em> directory and a <em>templates</em> directory. Templates are\nRuby templates which define a particular configuration file. For example, in\norder for Chef to be able to properly configure nginx with the proper server\nname, it needs to know on what domain your application will be hosted. More on\nthis later, but there is a master file which has all your settings in it and\nChef reads from that and substitutes the necessary values. The <em>files</em>\ndirectory contains files that need no further modification and can be copied\nover&nbsp;verbatim.</p>\n</div>\n<div class=\"section\" id=\"node-json\">\n<h2>node.json</h2>\n<p>The <em>node.json</em> file is a per project file that specifies certain values for\nChef to use. For example, you can tell Chef what you want your PostgreSQL\ndatabase to be called, what the name of your django project is, etc. It has a\nsimple <span class=\"caps\">JSON</span>&nbsp;syntax.</p>\n</div>\n<div class=\"section\" id=\"your-app-s-recipe\">\n<h2>Your app&#8217;s&nbsp;recipe</h2>\n<p>Your application is going to need a simple recipe. This means creating a\ncookbook bearing your project&#8217;s name and creating a <em>recipes</em> directory within\nin. The recipe should be called <em>default.rb</em> and all it needs to include is a\nlist of applications to install. For&nbsp;example:</p>\n<div class=\"highlight\"><pre><span class=\"c1\"># Example django app cookbook</span>\n\n<span class=\"n\">execute</span> <span class=\"s2\">&quot;Update apt repos&quot;</span> <span class=\"k\">do</span>\n    <span class=\"n\">command</span> <span class=\"s2\">&quot;apt-get update&quot;</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">include_recipe</span> <span class=\"s1\">&#39;nginx&#39;</span>\n<span class=\"n\">include_recipe</span> <span class=\"s1\">&#39;build-essential&#39;</span>\n<span class=\"n\">include_recipe</span> <span class=\"s1\">&#39;python&#39;</span>\n<span class=\"n\">include_recipe</span> <span class=\"s1\">&#39;postgresql::server&#39;</span>\n<span class=\"n\">include_recipe</span> <span class=\"s1\">&#39;memcached&#39;</span>\n<span class=\"n\">include_recipe</span> <span class=\"s1\">&#39;runit&#39;</span>\n<span class=\"n\">include_recipe</span> <span class=\"s1\">&#39;git&#39;</span>\n\n<span class=\"n\">execute</span> <span class=\"s2\">&quot;restart postgres&quot;</span> <span class=\"k\">do</span>\n    <span class=\"n\">command</span> <span class=\"s2\">&quot;sudo /etc/init.d/postgresql-8.4 restart&quot;</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">execute</span> <span class=\"s2\">&quot;create-database&quot;</span> <span class=\"k\">do</span>\n    <span class=\"n\">command</span> <span class=\"s2\">&quot;createdb -U postgres -O postgres </span><span class=\"si\">#{</span><span class=\"n\">node</span><span class=\"o\">[</span><span class=\"ss\">:dbname</span><span class=\"o\">]</span><span class=\"si\">}</span><span class=\"s2\">&quot;</span>\n<span class=\"k\">end</span>\n</pre></div>\n<p>You can see it&#8217;s pretty simple. We update Ubuntu&#8217;s repositories, include some\nrecipes, restart PostgreSQL and create a new&nbsp;database.</p>\n</div>\n<div class=\"section\" id=\"start-the-engines\">\n<h2>Start the&nbsp;engines</h2>\n<p>At this point, you can try out your configuration with Vagrant. To help you\nout, I have create a <a class=\"reference external\" href=\"https://github.com/honza/django-chef\">template</a> project on Github that you can download and\nuse out of the&nbsp;box.</p>\n<p>The next big part is writing the Fabric scripts. You will want the following&nbsp;tasks:</p>\n<ul>\n<li><p class=\"first\">Install&nbsp;Chef</p>\n</li>\n<li><p class=\"first\">Transfer the cookbooks directory to the&nbsp;server</p>\n</li>\n<li><dl class=\"first docutils\">\n<dt>Bootstrap the Django&nbsp;project</dt>\n<dd><ul class=\"first last simple\">\n<li>Moving code to the&nbsp;server</li>\n<li>Creating a&nbsp;virtualenv</li>\n<li>Installing&nbsp;requirements</li>\n<li>Syncing the&nbsp;database</li>\n<li>Running&nbsp;migrations</li>\n<li>Starting&nbsp;gunicorn</li>\n</ul>\n</dd>\n</dl>\n</li>\n<li><p class=\"first\">Deploy</p>\n</li>\n</ul>\n<p>You can see how I implemented mine <a class=\"reference external\" href=\"https://github.com/honza/django-chef/blob/master/fabfile.py\">here</a>. I recommend that you use Fabric&#8217;s\n<em>roledefs</em> which will allow you to specify vagrant as the&nbsp;host:</p>\n<div class=\"highlight\"><pre><span class=\"gp\">$</span> fab -R vagrant bootstrap\n</pre></div>\n</div>\n<div class=\"section\" id=\"the-real-thing\">\n<h2>The real&nbsp;thing</h2>\n<p>Once you&#8217;ve tested your application in Vagrant so you are ready to deploy to a\nserver. All that&#8217;s left to do is create a new <em>roledef</em> in the <em>fabfile</em> and\nrun&nbsp;it!</p>\n</div>\n<div class=\"section\" id=\"conclusion\">\n<h2>Conclusion</h2>\n<p>I am by no means a Chef expert&#8212;I learned how to use it a few days ago. If you\nhave any feedback, do let me&nbsp;know.</p>\n</div>\n</div>\n", 
    "date_iso": "2011-09-20", 
    "title": "Using Chef with small Django apps", 
    "url": "/2011/09/using-chef-with-small-django-apps", 
    "day": "20", 
    "categories": [
        {
            "name": "Django", 
            "slug": "django"
        }, 
        {
            "name": "Chef", 
            "slug": "chef"
        }, 
        {
            "name": "Python", 
            "slug": "python"
        }, 
        {
            "name": "Code", 
            "slug": "code"
        }
    ]
}