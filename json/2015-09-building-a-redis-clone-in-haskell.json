{
    "reading_time": "14 minutes", 
    "month": "09", 
    "year": "2015", 
    "date": "September 03, 2015", 
    "slug": "building-a-redis-clone-in-haskell", 
    "contents": "<div class=\"section\" id=\"building-a-redis-clone-in-haskell\">\n<h1>Building a Redis clone in&nbsp;Haskell</h1>\n<p>In this post, we will attempt to make a simplified clone of <a class=\"reference external\" href=\"http://redis.io\">Redis</a> in Haskell.\nHere is a set of requirements that we will aim to&nbsp;fullfill:</p>\n<ul class=\"simple\">\n<li><tt class=\"docutils literal\">get</tt> and <tt class=\"docutils literal\">set</tt> operations</li>\n<li>Multi-threaded</li>\n<li>Atomic</li>\n<li>Redis compatible (implement the Redis&nbsp;protocol)</li>\n</ul>\n<p>We should be able to use the <tt class=\"docutils literal\"><span class=\"pre\">redis-cli</span></tt> tool to connect to our server and\nissue commands to&nbsp;it.</p>\n<p>We are going to omit many features that Redis has.  For example, there will be\nno disk persistence.  We will accomplish this with about 100 lines of&nbsp;Haskell.</p>\n<div class=\"section\" id=\"getting-started-stack\">\n<h2>Getting started:&nbsp;stack</h2>\n<p>We are going to use <a class=\"reference external\" href=\"https://github.com/commercialhaskell/stack\">stack</a> to build our project.  Stack is a new build tool for\nHaskell projects.  We can also use it to create all the necessary files that\nmake up a Haskell project.  You can find the installation <a class=\"reference external\" href=\"https://github.com/commercialhaskell/stack/wiki/Downloads\">instructions</a>&nbsp;here.</p>\n<p>Let&#8217;s create our project.  We will call our server <em>Redish</em>.</p>\n<pre class=\"literal-block\">\n$ stack new Redish simple\n</pre>\n<p>This will create a directory <tt class=\"docutils literal\">Redish/</tt> with a few files in&nbsp;it.</p>\n<pre class=\"literal-block\">\nRedish/\n    LICENSE\n    README.md\n    Redish.cabal\n    Setup.hs\n    src/\n        Main.hs\n    stack.yaml\n</pre>\n<p>You can use stack to build this project and run&nbsp;it:</p>\n<pre class=\"literal-block\">\n$ stack build\nRedish-0.1.0.0: configure\nConfiguring Redish-0.1.0.0...\nRedish-0.1.0.0: build\nPreprocessing executable 'Redish' for Redish-0.1.0.0...\n[1 of 1] Compiling Main             ( src/Main.hs, .stack-work/dist/x86_64-osx/Cabal-1.22.4.0/build/Redish/Redish-tmp/Main.o )\nLinking .stack-work/dist/x86_64-osx/Cabal-1.22.4.0/build/Redish/Redish ...\nReidhs-0.1.0.0: install\nInstalling executable(s) in\n/Users/&lt;user&gt;/&lt;dirs&gt;/Redish/.stack-work/install/x86_64-osx/lts-3.2/7.10.2/bin\n$ stack exec Redish\nhello world\n</pre>\n</div>\n<div class=\"section\" id=\"types\">\n<h2>Types</h2>\n<p>Let&#8217;s start by defining our types.  Redish is an in-memory database so we will\nneed a representation of our database.  For a simple key-value store, all that\nwe need is a simple map.  Let&#8217;s create a few&nbsp;aliases.</p>\n<div class=\"highlight\"><pre><span class=\"kr\">type</span> <span class=\"kt\">Value</span> <span class=\"ow\">=</span> <span class=\"kt\">ByteString</span>\n<span class=\"kr\">type</span> <span class=\"kt\">Key</span>   <span class=\"ow\">=</span> <span class=\"kt\">ByteString</span>\n<span class=\"kr\">type</span> <span class=\"kt\"><span class=\"caps\">DB</span></span>    <span class=\"ow\">=</span> <span class=\"kt\">Map</span> <span class=\"kt\">Key</span> <span class=\"kt\">Value</span>\n</pre></div>\n<p>Next, we will need to represent the commands that our server knows how to\nhandle.  The command data structure can be a <tt class=\"docutils literal\">get</tt>, a <tt class=\"docutils literal\">set</tt> or&nbsp;unknown.</p>\n<div class=\"highlight\"><pre><span class=\"kr\">data</span> <span class=\"kt\">Command</span> <span class=\"ow\">=</span> <span class=\"kt\">Get</span> <span class=\"kt\">Key</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Set</span> <span class=\"kt\">Key</span> <span class=\"kt\">Value</span>\n             <span class=\"o\">|</span> <span class=\"kt\">Unknown</span>\n             <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span><span class=\"p\">,</span> <span class=\"kt\">Show</span><span class=\"p\">)</span>\n</pre></div>\n</div>\n<div class=\"section\" id=\"software-transactional-memory\">\n<h2>Software transactional&nbsp;memory</h2>\n<p>Now that we have our types in places, we need to write a few functions to\noperate on them.  We need a way to insert data and to query our&nbsp;database.</p>\n<p>First things first though.  Since by default everything in Haskell is immutable,\nhow can we change the value of our in-memory database?  We can&#8217;t simply\noverwrite the old value with the new one.  The compiler won&#8217;t let us.  The\nanswer is software transactional memory, or <span class=\"caps\">STM</span> for&nbsp;short.</p>\n<p><span class=\"caps\">STM</span> allows us to atomically change a value in our program.  The atomic part is\nimportant.  Many parts of the code can update this value and we have no way of\nknowing when and how often they might do so.  <span class=\"caps\">STM</span> allows us to perform atomic\nupdates.  This way any updates to our database will be run sequence even when\ncoming from different threads.  The only cost is that we have to perform any\nupdates within the context of <tt class=\"docutils literal\"><span class=\"caps\">IO</span></tt>.</p>\n<p>Our <tt class=\"docutils literal\"><span class=\"caps\">DB</span></tt> type will be become <tt class=\"docutils literal\">TVar <span class=\"caps\">DB</span></tt>.  The <tt class=\"docutils literal\">TVar</tt> type represents the\nmutable reference.  Next, let&#8217;s create the initial value in the <tt class=\"docutils literal\">main</tt>\nfunction:</p>\n<div class=\"highlight\"><pre><span class=\"nf\">main</span> <span class=\"ow\">::</span> <span class=\"kt\"><span class=\"caps\">IO</span></span> <span class=\"nb\">()</span>\n<span class=\"nf\">main</span> <span class=\"ow\">=</span> <span class=\"kr\">do</span>\n    <span class=\"n\">database</span> <span class=\"ow\">&lt;-</span> <span class=\"n\">atomically</span> <span class=\"o\">$</span> <span class=\"n\">newTVar</span> <span class=\"o\">$</span> <span class=\"n\">fromList</span> <span class=\"p\">[(</span><span class=\"s\">&quot;__version__&quot;</span><span class=\"p\">,</span> <span class=\"s\">&quot;0.1.0&quot;</span><span class=\"p\">)]</span>\n</pre></div>\n<p>This will create a <tt class=\"docutils literal\">Map</tt> with a key of <tt class=\"docutils literal\">__version__</tt> which has the value\n<tt class=\"docutils literal\">0.1.0</tt>.  Then, it wraps that <tt class=\"docutils literal\">Map</tt> in a <tt class=\"docutils literal\">TVar</tt> and atomically assigns it\nto the <tt class=\"docutils literal\">database</tt> variable.  Each time we want to write or read the\n<tt class=\"docutils literal\">database</tt> value, we have to use <tt class=\"docutils literal\"><span class=\"caps\">IO</span></tt>.  Let&#8217;s create a helper for atomically\nreading this&nbsp;value:</p>\n<div class=\"highlight\"><pre><span class=\"nf\">atomRead</span> <span class=\"ow\">::</span> <span class=\"kt\">TVar</span> <span class=\"n\">a</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\"><span class=\"caps\">IO</span></span> <span class=\"n\">a</span>\n<span class=\"nf\">atomRead</span> <span class=\"ow\">=</span> <span class=\"n\">atomically</span> <span class=\"o\">.</span> <span class=\"n\">readTVar</span>\n</pre></div>\n<p>And let&#8217;s make a function to update a value in the database.  This takes a\nfunction that does the updating and runs it through the <span class=\"caps\">STM</span>&nbsp;machinery.</p>\n<div class=\"highlight\"><pre><span class=\"nf\">updateValue</span> <span class=\"ow\">::</span> <span class=\"p\">(</span><span class=\"kt\"><span class=\"caps\">DB</span></span> <span class=\"ow\">-&gt;</span> <span class=\"kt\"><span class=\"caps\">DB</span></span><span class=\"p\">)</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">TVar</span> <span class=\"kt\"><span class=\"caps\">DB</span></span> <span class=\"ow\">-&gt;</span> <span class=\"kt\"><span class=\"caps\">IO</span></span> <span class=\"nb\">()</span>\n<span class=\"nf\">updateValue</span> <span class=\"n\">fn</span> <span class=\"n\">x</span> <span class=\"ow\">=</span> <span class=\"n\">atomically</span> <span class=\"o\">$</span> <span class=\"n\">modifyTVar</span> <span class=\"n\">x</span> <span class=\"n\">fn</span>\n</pre></div>\n</div>\n<div class=\"section\" id=\"reply-parsing\">\n<h2>Reply&nbsp;parsing</h2>\n<p>Next, let&#8217;s talk about the Redis protocol.  It&#8217;s a simple <span class=\"caps\">TCP</span> scheme that looks\nlike&nbsp;this:</p>\n<pre class=\"literal-block\">\n*2\\r\\n$3\\r\\nget\\r\\n$4\\r\\nname\n</pre>\n<p>It&#8217;s a bunch of keywords and arguments separated by newlines.  If we clean it up\nand break each thing to its own line, we&nbsp;get:</p>\n<pre class=\"literal-block\">\n*2\n$3\nget\n$4\nname\n</pre>\n<p>Let&#8217;s look at each line.  <tt class=\"docutils literal\">*2</tt> says to expect a command that has two\narguments.  <tt class=\"docutils literal\">$3</tt> says that the first argument is three characters long.\n<tt class=\"docutils literal\">get</tt> is the three-character argument from above.  <tt class=\"docutils literal\">$4</tt> is the length of the\nsecond argument, and <tt class=\"docutils literal\">name</tt> is the value of the second argument.  If you&#8217;re in\nthe <span class=\"caps\">REPL</span> provided by <tt class=\"docutils literal\"><span class=\"pre\">redis-cli</span></tt>, and you type <tt class=\"docutils literal\">get name</tt>, Redis will\ntranslate those two words into the above representation.  A <tt class=\"docutils literal\">set</tt> command\nwould look like&nbsp;this:</p>\n<pre class=\"literal-block\">\n*3\n$3\nset\n$4\nname\n$5\nhonza\n</pre>\n<p>This is what will be sent when you run <tt class=\"docutils literal\">set name honza</tt>.</p>\n<p>This multi-argument message is called <em>multibulk</em> in the Redis documentation.\nThere are two other data types that Redis uses that will interest us: the <span class=\"caps\">OK</span> and\nthe&nbsp;error.</p>\n<p>When Redis needs to tell you that it accepted request and everything went\nsmoothly, it simply responds with <tt class=\"docutils literal\">+<span class=\"caps\">OK</span></tt>.  When Redis needs to indicate an\nerror, it replies with <tt class=\"docutils literal\"><span class=\"pre\">-<span class=\"caps\">ERR</span></span> something went wrong</tt> (where &#8220;something went\nwrong&#8221; is the&nbsp;message).</p>\n<p>This format is very simple and actually very effective.  When we listen on a\nsocket for incoming messages, we have a look at the very first character.  <tt class=\"docutils literal\">+</tt>\ntells us that it&#8217;s <span class=\"caps\">OK</span>, <tt class=\"docutils literal\">-</tt> signals and error, and <tt class=\"docutils literal\">*</tt> tells us to keep\nreading for commands.  We incrementally read from the socket only as much data\nas the protocol tells&nbsp;us.</p>\n<p>In this section, we will write a parser for multibulk messages.  We will use the\namazing attoparsec library for&nbsp;this.</p>\n<blockquote>\nThe following code is heavily influenced by the <a class=\"reference external\" href=\"https://github.com/informatikr/hedis\">Hedis</a> library.  Credit goes\nto Falko Peters.  Thanks!</blockquote>\n<p>A multibulk message is called a <em>reply</em> in Redis lingo.  Let&#8217;s make a type for&nbsp;it.</p>\n<div class=\"highlight\"><pre><span class=\"kr\">data</span> <span class=\"kt\">Reply</span> <span class=\"ow\">=</span> <span class=\"kt\">Bulk</span> <span class=\"p\">(</span><span class=\"kt\">Maybe</span> <span class=\"kt\">ByteString</span><span class=\"p\">)</span>\n           <span class=\"o\">|</span> <span class=\"kt\">MultiBulk</span> <span class=\"p\">(</span><span class=\"kt\">Maybe</span> <span class=\"p\">[</span><span class=\"kt\">Reply</span><span class=\"p\">])</span>\n           <span class=\"kr\">deriving</span> <span class=\"p\">(</span><span class=\"kt\">Eq</span><span class=\"p\">,</span> <span class=\"kt\">Show</span><span class=\"p\">)</span>\n</pre></div>\n<p>A <tt class=\"docutils literal\">Bulk</tt> reply is a simple string like <tt class=\"docutils literal\">get</tt> or <tt class=\"docutils literal\">name</tt> above.\n<tt class=\"docutils literal\">MultiBulk</tt> is the whole message.  Let&#8217;s also write a function that attempts\nto convert a <tt class=\"docutils literal\">Reply</tt> to a <tt class=\"docutils literal\">Command</tt>.</p>\n<div class=\"highlight\"><pre><span class=\"nf\">parseReply</span> <span class=\"ow\">::</span> <span class=\"kt\">Reply</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Maybe</span> <span class=\"kt\">Command</span>\n<span class=\"nf\">parseReply</span> <span class=\"p\">(</span><span class=\"kt\">MultiBulk</span> <span class=\"p\">(</span><span class=\"kt\">Just</span> <span class=\"n\">xs</span><span class=\"p\">))</span> <span class=\"ow\">=</span>\n  <span class=\"kr\">case</span> <span class=\"n\">xs</span> <span class=\"kr\">of</span>\n    <span class=\"p\">[</span><span class=\"kt\">Bulk</span> <span class=\"p\">(</span><span class=\"kt\">Just</span> <span class=\"s\">&quot;get&quot;</span><span class=\"p\">),</span> <span class=\"kt\">Bulk</span> <span class=\"p\">(</span><span class=\"kt\">Just</span> <span class=\"n\">a</span><span class=\"p\">)]</span>                <span class=\"ow\">-&gt;</span> <span class=\"kt\">Just</span> <span class=\"o\">$</span> <span class=\"kt\">Get</span> <span class=\"n\">a</span>\n    <span class=\"p\">[</span><span class=\"kt\">Bulk</span> <span class=\"p\">(</span><span class=\"kt\">Just</span> <span class=\"s\">&quot;set&quot;</span><span class=\"p\">),</span> <span class=\"kt\">Bulk</span> <span class=\"p\">(</span><span class=\"kt\">Just</span> <span class=\"n\">a</span><span class=\"p\">),</span> <span class=\"kt\">Bulk</span> <span class=\"p\">(</span><span class=\"kt\">Just</span> <span class=\"n\">b</span><span class=\"p\">)]</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Just</span> <span class=\"o\">$</span> <span class=\"kt\">Set</span> <span class=\"n\">a</span> <span class=\"n\">b</span>\n    <span class=\"kr\">_</span>                                                 <span class=\"ow\">-&gt;</span> <span class=\"kt\">Just</span> <span class=\"kt\">Unknown</span>\n<span class=\"nf\">parseReply</span> <span class=\"kr\">_</span> <span class=\"ow\">=</span> <span class=\"kt\">Nothing</span>\n</pre></div>\n<p>Next, let&#8217;s use attoparsec to write a parser for the <tt class=\"docutils literal\">Reply</tt> data&nbsp;type.</p>\n<div class=\"highlight\"><pre><span class=\"nf\">replyParser</span> <span class=\"ow\">::</span> <span class=\"kt\">Parser</span> <span class=\"kt\">Reply</span>\n<span class=\"nf\">replyParser</span> <span class=\"ow\">=</span> <span class=\"n\">choice</span> <span class=\"p\">[</span><span class=\"n\">bulk</span><span class=\"p\">,</span> <span class=\"n\">multiBulk</span><span class=\"p\">]</span>\n</pre></div>\n<p>Our <tt class=\"docutils literal\">replyParser</tt> will try to match either a <tt class=\"docutils literal\">bulk</tt> or a <tt class=\"docutils literal\">multiBulk</tt>.\nLet&#8217;s implement&nbsp;those:</p>\n<div class=\"highlight\"><pre><span class=\"nf\">bulk</span> <span class=\"ow\">::</span> <span class=\"kt\">Parser</span> <span class=\"kt\">Reply</span>\n<span class=\"nf\">bulk</span> <span class=\"ow\">=</span> <span class=\"kt\">Bulk</span> <span class=\"o\">&lt;$&gt;</span> <span class=\"kr\">do</span>\n    <span class=\"n\">len</span> <span class=\"ow\">&lt;-</span> <span class=\"n\">char</span> <span class=\"sc\">&#39;$&#39;</span> <span class=\"o\">*&gt;</span> <span class=\"n\">signed</span> <span class=\"n\">decimal</span> <span class=\"o\">&lt;*</span> <span class=\"n\">endOfLine</span>\n    <span class=\"kr\">if</span> <span class=\"n\">len</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span>\n        <span class=\"kr\">then</span> <span class=\"n\">return</span> <span class=\"kt\">Nothing</span>\n        <span class=\"kr\">else</span> <span class=\"kt\">Just</span> <span class=\"o\">&lt;$&gt;</span> <span class=\"n\">take</span> <span class=\"n\">len</span> <span class=\"o\">&lt;*</span> <span class=\"n\">endOfLine</span>\n\n<span class=\"nf\">multiBulk</span> <span class=\"ow\">::</span> <span class=\"kt\">Parser</span> <span class=\"kt\">Reply</span>\n<span class=\"nf\">multiBulk</span> <span class=\"ow\">=</span> <span class=\"kt\">MultiBulk</span> <span class=\"o\">&lt;$&gt;</span> <span class=\"kr\">do</span>\n    <span class=\"n\">len</span> <span class=\"ow\">&lt;-</span> <span class=\"n\">char</span> <span class=\"sc\">&#39;*&#39;</span> <span class=\"o\">*&gt;</span> <span class=\"n\">signed</span> <span class=\"n\">decimal</span> <span class=\"o\">&lt;*</span> <span class=\"n\">endOfLine</span>\n    <span class=\"kr\">if</span> <span class=\"n\">len</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span>\n        <span class=\"kr\">then</span> <span class=\"n\">return</span> <span class=\"kt\">Nothing</span>\n        <span class=\"kr\">else</span> <span class=\"kt\">Just</span> <span class=\"o\">&lt;$&gt;</span> <span class=\"n\">count</span> <span class=\"n\">len</span> <span class=\"n\">replyParser</span>\n</pre></div>\n<p>First, the parsers look at the first character to see what kind of message it\nis.  If it starts with a <tt class=\"docutils literal\">$</tt>, it&#8217;s a bulk.  If it starts with a <tt class=\"docutils literal\">*</tt>, it&#8217;s\nmultibulk.  Then, it reads as many characters from the input as the length\nindicator said.  In the case of multibulk, it recurses because it can contain\nbulk&nbsp;messages.</p>\n<p>You can now&nbsp;run:</p>\n<div class=\"highlight\"><pre><span class=\"o\">&gt;</span> <span class=\"n\">parse</span> <span class=\"n\">replyParser</span> <span class=\"s\">&quot;*2</span><span class=\"se\">\\r\\n</span><span class=\"s\">$3</span><span class=\"se\">\\r\\n</span><span class=\"s\">get</span><span class=\"se\">\\r\\n</span><span class=\"s\">$4</span><span class=\"se\">\\r\\n</span><span class=\"s\">name</span><span class=\"se\">\\r\\n</span><span class=\"s\">&quot;</span>\n<span class=\"o\">&gt;</span> <span class=\"p\">(</span><span class=\"kt\">MultiBulk</span> <span class=\"p\">(</span><span class=\"kt\">Just</span> <span class=\"p\">[(</span><span class=\"kt\">Bulk</span> <span class=\"p\">(</span><span class=\"kt\">Just</span> <span class=\"s\">&quot;get&quot;</span><span class=\"p\">)),</span> <span class=\"p\">(</span><span class=\"kt\">Bulk</span> <span class=\"p\">(</span><span class=\"kt\">Just</span> <span class=\"s\">&quot;name&quot;</span><span class=\"p\">))]))</span>\n</pre></div>\n</div>\n<div class=\"section\" id=\"networking\">\n<h2>Networking</h2>\n<p>At this point, we have our data structures ready and we know how to parse\nincoming requests into them.  Now we need to work on the networking part.  Let&#8217;s\nteach our program how to listen on a socket and parse incoming text into\nsomething&nbsp;useful.</p>\n<p>Let&#8217;s change our <tt class=\"docutils literal\">main</tt> function to&nbsp;this:</p>\n<div class=\"highlight\"><pre><span class=\"nf\">main</span> <span class=\"ow\">::</span> <span class=\"kt\"><span class=\"caps\">IO</span></span> <span class=\"nb\">()</span>\n<span class=\"nf\">main</span> <span class=\"ow\">=</span> <span class=\"n\">withSocketsDo</span> <span class=\"o\">$</span> <span class=\"kr\">do</span>\n    <span class=\"n\">database</span> <span class=\"ow\">&lt;-</span> <span class=\"n\">atomically</span> <span class=\"o\">$</span> <span class=\"n\">newTVar</span> <span class=\"o\">$</span> <span class=\"n\">fromList</span> <span class=\"p\">[(</span><span class=\"s\">&quot;__version__&quot;</span><span class=\"p\">,</span> <span class=\"n\">version</span><span class=\"p\">)]</span>\n    <span class=\"n\">sock</span> <span class=\"ow\">&lt;-</span> <span class=\"n\">listenOn</span> <span class=\"o\">$</span> <span class=\"kt\">PortNumber</span> <span class=\"mi\">7777</span>\n    <span class=\"n\">putStrLn</span> <span class=\"s\">&quot;Listening on localhost 7777&quot;</span>\n    <span class=\"n\">sockHandler</span> <span class=\"n\">sock</span> <span class=\"n\">database</span>\n</pre></div>\n<p>This is pretty straight-forward.  Ask for a socket and then listen on it.  When\nsomething happens on the socket, run the function <tt class=\"docutils literal\">socketHandler</tt>.  Let&#8217;s\nimplement that&nbsp;next:</p>\n<div class=\"highlight\"><pre><span class=\"nf\">sockHandler</span> <span class=\"ow\">::</span> <span class=\"kt\">Socket</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">TVar</span> <span class=\"kt\"><span class=\"caps\">DB</span></span> <span class=\"ow\">-&gt;</span> <span class=\"kt\"><span class=\"caps\">IO</span></span> <span class=\"nb\">()</span>\n<span class=\"nf\">sockHandler</span> <span class=\"n\">sock</span> <span class=\"n\">db</span> <span class=\"ow\">=</span> <span class=\"kr\">do</span>\n    <span class=\"p\">(</span><span class=\"n\">handle</span><span class=\"p\">,</span> <span class=\"kr\">_</span><span class=\"p\">,</span> <span class=\"kr\">_</span><span class=\"p\">)</span> <span class=\"ow\">&lt;-</span> <span class=\"n\">accept</span> <span class=\"n\">sock</span>\n    <span class=\"n\">hSetBuffering</span> <span class=\"n\">handle</span> <span class=\"kt\">NoBuffering</span>\n    <span class=\"n\">hSetBinaryMode</span> <span class=\"n\">handle</span> <span class=\"kt\">True</span>\n    <span class=\"kr\">_</span> <span class=\"ow\">&lt;-</span> <span class=\"n\">forkIO</span> <span class=\"o\">$</span> <span class=\"n\">commandProcessor</span> <span class=\"n\">handle</span> <span class=\"n\">db</span>\n    <span class=\"n\">sockHandler</span> <span class=\"n\">sock</span> <span class=\"n\">db</span>\n</pre></div>\n<p>Given a socket and a reference to a mutable database, we can get a handle and\nstart processing requests.  For each new connection, run <tt class=\"docutils literal\">forkIO</tt> which will\ndo all this work of parsing and responding on a new lightweight thread.  At the\nend, we simply recurse to accept new work.  The <tt class=\"docutils literal\">commandProcessor</tt> function\ndoes the heavy lifting here, so let&#8217;s write that&nbsp;next.</p>\n<div class=\"highlight\"><pre><span class=\"nf\">commandProcessor</span> <span class=\"ow\">::</span> <span class=\"kt\">Handle</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">TVar</span> <span class=\"kt\"><span class=\"caps\">DB</span></span> <span class=\"ow\">-&gt;</span> <span class=\"kt\"><span class=\"caps\">IO</span></span> <span class=\"nb\">()</span>\n<span class=\"nf\">commandProcessor</span> <span class=\"n\">handle</span> <span class=\"n\">db</span> <span class=\"ow\">=</span> <span class=\"kr\">do</span>\n    <span class=\"n\">reply</span> <span class=\"ow\">&lt;-</span> <span class=\"n\">hGetReplies</span> <span class=\"n\">handle</span> <span class=\"n\">replyParser</span>\n    <span class=\"kr\">let</span> <span class=\"n\">command</span> <span class=\"ow\">=</span> <span class=\"n\">parseReply</span> <span class=\"n\">reply</span>\n    <span class=\"n\">runCommand</span> <span class=\"n\">handle</span> <span class=\"n\">command</span> <span class=\"n\">db</span>\n    <span class=\"n\">commandProcessor</span> <span class=\"n\">handle</span> <span class=\"n\">db</span>\n</pre></div>\n<p>This function runs the <tt class=\"docutils literal\">replyParser</tt> we wrote earlier.  It uses a very clever\nfunction called <tt class=\"docutils literal\">hGetReplies</tt> which we will look at in a minute.  It will read\nas much data as necessary from the handle to get an instance of <tt class=\"docutils literal\">Reply</tt>.  We\nthen convert that reply to a command and run&nbsp;it.</p>\n<div class=\"highlight\"><pre><span class=\"nf\">hGetReplies</span> <span class=\"ow\">::</span> <span class=\"kt\">Handle</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Parser</span> <span class=\"n\">a</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\"><span class=\"caps\">IO</span></span> <span class=\"n\">a</span>\n<span class=\"nf\">hGetReplies</span> <span class=\"n\">h</span> <span class=\"n\">parser</span> <span class=\"ow\">=</span> <span class=\"n\">go</span> <span class=\"kt\">S</span><span class=\"o\">.</span><span class=\"n\">empty</span>\n  <span class=\"kr\">where</span>\n    <span class=\"n\">go</span> <span class=\"n\">rest</span> <span class=\"ow\">=</span> <span class=\"kr\">do</span>\n        <span class=\"n\">parseResult</span> <span class=\"ow\">&lt;-</span> <span class=\"n\">parseWith</span> <span class=\"n\">readMore</span> <span class=\"n\">parser</span> <span class=\"n\">rest</span>\n        <span class=\"kr\">case</span> <span class=\"n\">parseResult</span> <span class=\"kr\">of</span>\n            <span class=\"kt\">Fail</span> <span class=\"kr\">_</span> <span class=\"kr\">_</span> <span class=\"n\">s</span>   <span class=\"ow\">-&gt;</span> <span class=\"ne\">error</span> <span class=\"n\">s</span>\n            <span class=\"kt\">Partial</span><span class=\"p\">{}</span>    <span class=\"ow\">-&gt;</span> <span class=\"ne\">error</span> <span class=\"s\">&quot;error: partial&quot;</span>\n            <span class=\"kt\">Done</span> <span class=\"kr\">_</span> <span class=\"n\">r</span>     <span class=\"ow\">-&gt;</span> <span class=\"n\">return</span> <span class=\"n\">r</span>\n\n    <span class=\"n\">readMore</span> <span class=\"ow\">=</span> <span class=\"kt\">S</span><span class=\"o\">.</span><span class=\"n\">hGetSome</span> <span class=\"n\">h</span> <span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"o\">*</span><span class=\"mi\">1024</span><span class=\"p\">)</span>\n</pre></div>\n<p>The <tt class=\"docutils literal\">parseWith</tt> function does partial matching.  When it can&#8217;t parse anything,\nit will use the <tt class=\"docutils literal\">readMore</tt> function to get more data and try again.  The\n<tt class=\"docutils literal\">readMore</tt> function uses the handle to read more data.  Once the parser can\nmatch something, we are&nbsp;done.</p>\n</div>\n<div class=\"section\" id=\"running-commands\">\n<h2>Running&nbsp;commands</h2>\n<p>Once we have a command, we can run&nbsp;it!</p>\n<div class=\"highlight\"><pre><span class=\"nf\">runCommand</span> <span class=\"ow\">::</span> <span class=\"kt\">Handle</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Maybe</span> <span class=\"kt\">Command</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">TVar</span> <span class=\"kt\"><span class=\"caps\">DB</span></span> <span class=\"ow\">-&gt;</span> <span class=\"kt\"><span class=\"caps\">IO</span></span> <span class=\"nb\">()</span>\n<span class=\"nf\">runCommand</span> <span class=\"n\">handle</span> <span class=\"p\">(</span><span class=\"kt\">Just</span> <span class=\"p\">(</span><span class=\"kt\">Get</span> <span class=\"n\">key</span><span class=\"p\">))</span> <span class=\"n\">db</span> <span class=\"ow\">=</span> <span class=\"kr\">do</span>\n    <span class=\"n\">m</span> <span class=\"ow\">&lt;-</span> <span class=\"n\">atomRead</span> <span class=\"n\">db</span>\n    <span class=\"kr\">let</span> <span class=\"n\">value</span> <span class=\"ow\">=</span> <span class=\"n\">getValue</span> <span class=\"n\">m</span> <span class=\"n\">key</span>\n    <span class=\"kt\">S</span><span class=\"o\">.</span><span class=\"n\">hPutStr</span> <span class=\"n\">handle</span> <span class=\"o\">$</span> <span class=\"kt\">S</span><span class=\"o\">.</span><span class=\"n\">concat</span> <span class=\"p\">[</span><span class=\"s\">&quot;$&quot;</span><span class=\"p\">,</span> <span class=\"n\">valLength</span> <span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">crlf</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">crlf</span><span class=\"p\">]</span>\n        <span class=\"kr\">where</span>\n            <span class=\"n\">valLength</span> <span class=\"ow\">::</span> <span class=\"kt\">Value</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">ByteString</span>\n            <span class=\"n\">valLength</span> <span class=\"ow\">=</span> <span class=\"n\">pack</span> <span class=\"o\">.</span> <span class=\"n\">show</span> <span class=\"o\">.</span> <span class=\"kt\">S</span><span class=\"o\">.</span><span class=\"n\">length</span>\n<span class=\"nf\">runCommand</span> <span class=\"n\">handle</span> <span class=\"p\">(</span><span class=\"kt\">Just</span> <span class=\"p\">(</span><span class=\"kt\">Set</span> <span class=\"n\">key</span> <span class=\"n\">value</span><span class=\"p\">))</span> <span class=\"n\">db</span> <span class=\"ow\">=</span> <span class=\"kr\">do</span>\n    <span class=\"n\">updateValue</span> <span class=\"p\">(</span><span class=\"n\">insert</span> <span class=\"n\">key</span> <span class=\"n\">value</span><span class=\"p\">)</span> <span class=\"n\">db</span>\n    <span class=\"kt\">S</span><span class=\"o\">.</span><span class=\"n\">hPutStr</span> <span class=\"n\">handle</span> <span class=\"n\">ok</span>\n<span class=\"nf\">runCommand</span> <span class=\"n\">handle</span> <span class=\"p\">(</span><span class=\"kt\">Just</span> <span class=\"kt\">Unknown</span><span class=\"p\">)</span> <span class=\"kr\">_</span> <span class=\"ow\">=</span>\n    <span class=\"kt\">S</span><span class=\"o\">.</span><span class=\"n\">hPutStr</span> <span class=\"n\">handle</span> <span class=\"o\">$</span> <span class=\"kt\">S</span><span class=\"o\">.</span><span class=\"n\">concat</span> <span class=\"p\">[</span><span class=\"s\">&quot;-<span class=\"caps\">ERR</span> &quot;</span><span class=\"p\">,</span> <span class=\"s\">&quot;unknown command&quot;</span><span class=\"p\">,</span> <span class=\"n\">crlf</span><span class=\"p\">]</span>\n<span class=\"nf\">runCommand</span> <span class=\"kr\">_</span> <span class=\"kt\">Nothing</span> <span class=\"kr\">_</span> <span class=\"ow\">=</span> <span class=\"n\">return</span> <span class=\"nb\">()</span>\n</pre></div>\n<p>When the command is a <tt class=\"docutils literal\">get</tt>, we read the <tt class=\"docutils literal\"><span class=\"caps\">DB</span></tt> atom.  Then we construct a\nbulk reply and write it to the handle.  The bulk reply is in the same format as\nour messages above: <tt class=\"docutils literal\">$5\\r\\nhonza\\r\\n</tt>.  The <tt class=\"docutils literal\">getValue</tt> function is a lookup\nfunction that returns &#8220;null&#8221; if a value can&#8217;t be&nbsp;found.</p>\n<div class=\"highlight\"><pre><span class=\"nf\">getValue</span> <span class=\"ow\">::</span> <span class=\"kt\"><span class=\"caps\">DB</span></span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Key</span> <span class=\"ow\">-&gt;</span> <span class=\"kt\">Value</span>\n<span class=\"nf\">getValue</span> <span class=\"n\">db</span> <span class=\"n\">k</span> <span class=\"ow\">=</span> <span class=\"n\">findWithDefault</span> <span class=\"s\">&quot;null&quot;</span> <span class=\"n\">k</span> <span class=\"n\">db</span>\n</pre></div>\n<p>When the command is a <tt class=\"docutils literal\">set</tt>, we use our <tt class=\"docutils literal\">updateValue</tt> function from above\nand write the <tt class=\"docutils literal\">ok</tt> to the handle.  The <tt class=\"docutils literal\">ok</tt> variable is just <tt class=\"docutils literal\">+<span class=\"caps\">OK</span>\\r\\n</tt>.</p>\n<p>When the command is unknown, we write an error to the&nbsp;handle.</p>\n</div>\n<div class=\"section\" id=\"compiling-and-running\">\n<h2>Compiling and&nbsp;running</h2>\n<p>You can now build your program&nbsp;with</p>\n<pre class=\"literal-block\">\n$ stack build\n</pre>\n<p>And run it&nbsp;with</p>\n<pre class=\"literal-block\">\n$ stack exec Redish\nListening on localhost 7777\n</pre>\n<p>To test it out, you can connect to it with the <tt class=\"docutils literal\"><span class=\"pre\">redis-cli</span></tt> tool:</p>\n<pre class=\"literal-block\">\n$ redis-cli -p 7777\n127.0.0.1:7777&gt; set name honza\nOK\n127.0.0.1:7777&gt; get name\n&quot;honza&quot;\n</pre>\n<p>You can test the performance with something silly,&nbsp;like:</p>\n<pre class=\"literal-block\">\n$ time redis-cli -r 10000 get name\n</pre>\n</div>\n<div class=\"section\" id=\"conclusion\">\n<h2>Conclusion</h2>\n<p>You can see the finished product on <a class=\"reference external\" href=\"https://github.com/honza/redish\">GitHub</a>.  Feedback is welcome, so are&nbsp;questions.</p>\n</div>\n</div>\n", 
    "date_iso": "2015-09-03", 
    "title": "Building a Redis clone in Haskell", 
    "url": "/2015/09/building-a-redis-clone-in-haskell", 
    "day": "03", 
    "categories": [
        {
            "name": "Haskell", 
            "slug": "haskell"
        }, 
        {
            "name": "Code", 
            "slug": "code"
        }
    ]
}