{
    "reading_time": "2 minutes", 
    "month": "05", 
    "year": "2012", 
    "date": "May 11, 2012", 
    "slug": "how-i-use-git", 
    "contents": "<div class=\"section\" id=\"how-i-use-git\">\n<h1>How I use&nbsp;git</h1>\n<p>Recently, I have noticed that there are quite a few wrappers around git to give\nyou a nicer interface to work with.  The new commands promise to be easy to\nremember and make your life less frustrating.  I find these a little silly\nbecause git on its own is a great tool.  Here I&#8217;m going to describe how I use\ngit to convince you (and myself) that it&#8217;s not that&nbsp;hard.</p>\n<div class=\"section\" id=\"cloning\">\n<h2>Cloning</h2>\n<p>This couldn&#8217;t be any&nbsp;simpler:</p>\n<pre class=\"literal-block\">\ngit clone git://github.com/honza/dotfiles.git\n</pre>\n</div>\n<div class=\"section\" id=\"committing\">\n<h2>Committing</h2>\n<p>Once I have cloned a repo, I start to make changes.  To see what files I have\nchanged, I&nbsp;run</p>\n<pre class=\"literal-block\">\ngit status\n</pre>\n<p>Or to see what actual changes I&nbsp;made</p>\n<pre class=\"literal-block\">\ngit diff\n</pre>\n<p>Then, when I&#8217;m ready to commit, I stage the files.  The index is one of my\nfavorite features of git.  It lets me decide what changes I want to commit.\nMaybe I correct something as I work on something else.  Those things aren&#8217;t\nrelated so they shouldn&#8217;t go into the same commit.  I grew up on Mercurial and\nnot having the index in Mercurial now really bothers&nbsp;me.</p>\n<p>To stage all changed files, I&nbsp;do</p>\n<pre class=\"literal-block\">\ngit add -u\n</pre>\n<p>If I decide that the changes I made are stupid and I want to get rid of them, I&nbsp;do</p>\n<pre class=\"literal-block\">\ngit checkout .\n</pre>\n<p>To make sure all staged changes are the right&nbsp;ones</p>\n<pre class=\"literal-block\">\ngit diff --cached\n</pre>\n</div>\n<div class=\"section\" id=\"stashing\">\n<h2>Stashing</h2>\n<p>I often stash my code.  Sometimes you need to look at some code in a different\nbranch, sometimes I notice something is broken and I want to see if I broke it\nor&nbsp;not.</p>\n<pre class=\"literal-block\">\ngit stash\n</pre>\n<p>will stash your changes.  To get it back I&nbsp;do</p>\n<pre class=\"literal-block\">\ngit stash pop\n</pre>\n<p>And also, often I will see what I had&nbsp;stashed</p>\n<pre class=\"literal-block\">\ngit stash list\n</pre>\n</div>\n<div class=\"section\" id=\"branches\">\n<h2>Branches</h2>\n<p>Creating new branches is simple and&nbsp;cheap</p>\n<pre class=\"literal-block\">\ngit checkout -b new_branch\n</pre>\n<p>Delete a&nbsp;branch</p>\n<pre class=\"literal-block\">\ngit branch -d branch_name\n</pre>\n<p>Or delete a branch on a remote&nbsp;server</p>\n<pre class=\"literal-block\">\ngit push origin :branch_name\n</pre>\n</div>\n<div class=\"section\" id=\"rebasing\">\n<h2>Rebasing</h2>\n<p>I have <a class=\"reference external\" href=\"http://honza.ca/2011/05/the-importance-of-git-rebase\">written</a> on\nrebasing before.  It makes your history much nicer.  Any time I pull code from\na remote repository, I&nbsp;do</p>\n<pre class=\"literal-block\">\ngit pull --rebase\n</pre>\n<p>Or, if it&#8217;s a specific&nbsp;branch</p>\n<pre class=\"literal-block\">\ngit pull --rebase origin dev\n</pre>\n</div>\n<div class=\"section\" id=\"bisecting\">\n<h2>Bisecting</h2>\n<p>I <em>love</em> the bisect commnad in git.  You can use it to determine which commit\nintroduced a bug.  This is especially useful if you have a comprehensive test\nsuite.  For example, the latest commit is broken and you remember that all\ntests where passing in version 1.2.  This example uses&nbsp;Django.</p>\n<pre class=\"literal-block\">\ngit bisect start HEAD v1.2 --      # HEAD is bad, v1.2 is good\ngit bisect run python manage.py test\n</pre>\n<p>Git will then keep running your tests until it finds the first commit that&#8217;s&nbsp;broken.</p>\n</div>\n<div class=\"section\" id=\"merging\">\n<h2>Merging</h2>\n<p>When a feature branch is finished, I merge it into master&nbsp;with</p>\n<pre class=\"literal-block\">\ngit checkout master\ngit merge --no-ff feature\n</pre>\n</div>\n<div class=\"section\" id=\"viewing-history\">\n<h2>Viewing&nbsp;history</h2>\n<p>For viewing history, I really like the following&nbsp;command</p>\n<pre class=\"literal-block\">\ngit log --pretty=format:&quot;%h - %an, %ar : %s&quot;'\n</pre>\n<p>This gives you the commit <span class=\"caps\">SHA</span>, then the author&#8217;s name, how long ago it was made\nand a brief, one-line summary of the changes.  I have it aliased as <tt class=\"docutils literal\">gitl</tt>.\nI also use a simple graph to see the relationships between&nbsp;branches</p>\n<pre class=\"literal-block\">\ngit log --oneline --graph\n</pre>\n</div>\n<div class=\"section\" id=\"upgrading-all-submodules-in-a-project\">\n<h2>Upgrading all submodules in a&nbsp;project</h2>\n<p>This one is great, too.  I use it to upgrade all of my vim&nbsp;plugins.</p>\n<pre class=\"literal-block\">\ngit submodule foreach git pull\n</pre>\n</div>\n<div class=\"section\" id=\"pulling-and-pushing\">\n<h2>Pulling and&nbsp;pushing</h2>\n<p>This is pretty straight&nbsp;forward</p>\n<pre class=\"literal-block\">\ngit pull\ngit pull origin dev\n\ngit push\ngit push origin dev\n</pre>\n</div>\n<div class=\"section\" id=\"conclusion\">\n<h2>Conclusion</h2>\n<p>Once you learn what git calls what, it&#8217;s pretty easy to just google the thing\nyou&#8217;re trying to do.  I&#8217;m definitely not an expert but this gets me&nbsp;by.</p>\n</div>\n</div>\n", 
    "date_iso": "2012-05-11", 
    "title": "How I use git", 
    "url": "/2012/05/how-i-use-git", 
    "day": "11", 
    "categories": [
        {
            "name": "git", 
            "slug": "git"
        }
    ]
}