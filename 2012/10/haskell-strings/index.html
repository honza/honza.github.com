<!doctype html lang="en">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="description" content="Thoughts of an open source developer with a theology degree. Honza Pokorny is a web developer and an armchair theologian in Halifax, Canada" >
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>Haskell Strings | Honza Pokorny</title>
  <link href="https://fonts.googleapis.com/css?family=Karla:400,400i|Montserrat:700&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="https://honza.cacss/index.css">
  <link rel="alternate" type="application/rss+xml" href="" title="Honza Pokorny">
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-4330851-12']);
        _gaq.push(['_trackPageview']);

        (function(){
         var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
         ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
         var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();

    </script>

</head>
<body>
        <div id="banner" class="container">
          <h1><a href="/">Honza Pokorny</a></h1>
          <p><em>Thoughts of an open source developer with a theology degree</em></p>
        </div>

    <div id="wrap">

<div class="single-header">
  <h1>Haskell Strings</h1>

</div>

<article>
  

<p>It continues to amaze me how bad Haskell is at processing strings.  One of the
reasons I wanted to learn Haskell was to be able to write short,
dynamic-language-like programs that execute fast once compiled.  Somehow
rather, Haskell has failed to deliver on its promise of <em>bare metal</em> speed.  I
mostly write scripts and utilities meant to run on my machine&mdash;these scripts
mostly process text.  Read a file, parse it and spit something out.</p>

<h2 id="example">Example</h2>

<p>Let&rsquo;s build a simple program that will show what I&rsquo;m talking about.</p>

<h3 id="read-a-file-called-file-which-contains-prose">Read a file called <code>file</code> which contains prose</h3>

<h3 id="capitalize-every-word-in-that-body-of-text">Capitalize every word in that body of text</h3>

<h3 id="print-the-result-to-stdout">Print the result to stdout</h3>

<p>We will be testing our programs with a file with about 1.2 million lines of
Lorem Ipsum.  This file is around 75MB.</p>

<p>Here is attemp number one.  This is really simple Haskell.</p>

<pre><code class="language-haskell">-- Normal.hs

module Main where
import Data.Char

convert :: String -&gt; String
convert = unlines . (map convertLine) . lines

convertLine :: String -&gt; String
convertLine = unwords . (map convertWord) . words

convertWord :: String -&gt; String
convertWord s = (toUpper (head s)):(tail s)

main = do
    name &lt;- readFile &quot;file&quot;
    putStr $ convert name
</code></pre>

<p>Compile and execute with</p>

<pre><code class="language-nil">ghc -O2 -o normal Normal.hs
time ./normal &gt; /dev/null
</code></pre>

<p>This takes about 17 seconds.  Let&rsquo;s see if we can do any better.  When you
complain about Strings in Haskell being slow on some neckbeard forum, people
will tell you to use <code>Data.Text</code>.</p>

<pre><code class="language-haskell">-- Main.hs

module Main where

import Data.Char
import qualified Data.Text as T
import qualified Data.Text.IO as X

convert :: T.Text -&gt; T.Text
convert = T.unlines . (map convertLine) . T.lines

convertLine :: T.Text -&gt; T.Text
convertLine = T.unwords . (map convertWord) . T.words

convertWord :: T.Text -&gt; T.Text
convertWord s = T.cons (toUpper (T.head s)) (T.tail s)

main = do
    name &lt;- X.readFile &quot;file&quot;
    X.putStr $ convert name
</code></pre>

<p>This is mostly the same as above.  Instead of using the <code>String</code> type to work
with text, we use the <code>Data.Text.Text</code> type.</p>

<pre><code class="language-nil">ghc -O2 -o main Main.hs
time ./main &gt; /dev/null
</code></pre>

<p>How did it do?  One entire minute, that&rsquo;s 5 times slower.  And it uses obscene
amounts of memory (around 600MB on my machine).  Let&rsquo;s use lazy IO when reading
the file, maybe it will improve.</p>

<pre><code class="language-haskell">-- change this
import qualified Data.Text as T
import qualified Data.Text.IO as X

-- to this
import qualified Data.Text.Lazy as T
import qualified Data.Text.Lazy.IO as X
</code></pre>

<p>This clocks in at 27 seconds.  Much better than the non-lazy version.  Next
thing to try is to ignore unicode and go for the ultimate, bare-metal speed.
Let&rsquo;s use <code>ByteString</code> instead of <code>Text</code>.</p>

<pre><code class="language-haskell">module Byte where

import Data.Char
import qualified Data.ByteString as B
import qualified Data.ByteString.Char8 as C

convert :: B.ByteString -&gt; B.ByteString
convert = C.unlines . (map convertLine) . C.lines

convertLine :: B.ByteString -&gt; B.ByteString
convertLine = C.unwords . (map convertWord) . C.words

convertWord :: B.ByteString -&gt; B.ByteString
convertWord s = C.cons (toUpper (C.head s)) (C.tail s)

main = do
    name &lt;- B.readFile &quot;file&quot;
    B.putStr $ convert name
</code></pre>

<p>Hm, not that much better.  27 seconds.  That&rsquo;s about as good as the lazy
version when using <code>Text</code>.  Let&rsquo;s see if we can squeeze more perfomance out
of this with a lazy <code>ByteString</code></p>

<pre><code class="language-haskell">-- change this
import qualified Data.ByteString as B
import qualified Data.ByteString.Char8 as C

-- to this
import qualified Data.ByteString.Lazy as B
import qualified Data.ByteString.Lazy.Char8 as C
</code></pre>

<p>This takes about 10 seconds.  Awesome.  This is the best I can do with Haskell.
10 seconds to process 1.2 million lines of text.  I guess that&rsquo;s not too bad.</p>

<p><strong>EDIT</strong>: Someone <a href="http://www.reddit.com/r/haskell/comments/120h6i/why%5Fis%5Fthis%5Fsimple%5Ftext%5Fprocessing%5Fprogram%5Fso/c6r6rm1">pointed out on Reddit</a> that this whole thing can be
accomplished as a simple one-liner.  This is actually a pretty elegant
solution.</p>

<pre><code class="language-haskell">module Main where

import Data.Char
import qualified Data.Text.Lazy as T
import qualified Data.Text.Lazy.IO as X

convert :: T.Text -&gt; T.Text
convert = T.tail . T.scanl (\a b -&gt; if isSpace a then toUpper b else b) ' '

main = do
    name &lt;- X.readFile &quot;file&quot;
    X.putStr $ convert name
</code></pre>

<p>This clocks in at 8.5 seconds.  Not bad at all.</p>

<p><strong>EDIT 5</strong>: Someone pointed out that I didn&rsquo;t include a version of the
one-liner that uses <code>ByteString</code>.</p>

<pre><code class="language-haskell">module Main where

import Data.Char
import qualified Data.ByteString.Char8 as T

convert :: T.ByteString -&gt; T.ByteString
convert = T.tail . T.scanl (\a b -&gt; if isSpace a then toUpper b else b) ' '

main = do
name &lt;- T.readFile &quot;file&quot;
T.putStr $ convert name
</code></pre>

<p>This clocks in at 3.5s on my machine.  Pretty fast!</p>

<h2 id="python">Python</h2>

<p>Let&rsquo;s try this in Python</p>

<pre><code class="language-python">def process(data):
    lines = data.split('\n')
    return &quot;\n&quot;.join([process_line(line) for line in lines])


def process_line(line):
    words = line.split(' ')
    new = [w.capitalize() for w in words]
    return &quot; &quot;.join(new)


if __name__ == '__main__':
    data = open('file').read()
    print process(data)
</code></pre>

<p>Execute with</p>

<pre><code class="language-nil">$ time python main.py &gt; /dev/null
</code></pre>

<p>Six seconds!  Six!  How can a dynamic language be so much faster than compiled
Haskell?</p>

<p><strong>EDIT 4</strong>: There has been some discussion on Reddit about being able to
accomplish this task in only one line in Haskell.  It&rsquo;s actually possible in
Python, too.</p>

<pre><code class="language-python">print open('file').read().title()
</code></pre>

<p>This clocks in at 2 seconds.</p>

<h2 id="javascript-and-v8">Javascript and V8</h2>

<pre><code class="language-javascript">// main.js

var fs = require('fs');

function capitalize(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}

function processLine(line) {
    var words = line.split(' ');
    for (var i=0; i &lt; words.length; i++) {
        words[i] = capitalize(words[i]);
    }

    return words.join(' ');
}

function run() {
    var data = fs.readFileSync('file', 'utf-8');
    var lines = data.split('\n');

    for (var i=0; i &lt; lines.length; i++) {
        lines[i] = processLine(lines[i]);
    }

    return lines.join(&quot;\n&quot;);
}

console.log(run());
</code></pre>

<p>Execute it with:</p>

<pre><code class="language-nil">$ time node main.js &gt; /dev/null
</code></pre>

<p>Wait for it!  4.5 seconds.  I have no words.</p>

<h2 id="how-about-go">How about Go?</h2>

<p><strong>EDIT 3</strong>: (Add this section.  Looks like this post is turning into a language
shootout, le sigh).</p>

<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;io/ioutil&quot;
    &quot;bytes&quot;
)

func main() {
    body, _ := ioutil.ReadFile(&quot;file&quot;)
    result := bytes.Title(body)
    fmt.Printf(&quot;%s&quot;, result)
}
</code></pre>

<p>Put this into <code>title.go</code>, compile and run with</p>

<pre><code class="language-nil">$ go build title.go
$ time ./title &gt; /dev/null
</code></pre>

<p>This is around 2 seconds.  Pretty crazy performance.  Only twice the time
compared to C.</p>

<h2 id="how-about-c">How about C?</h2>

<p><strong>EDIT 2</strong>: (Add this section)</p>

<p><a href="https://twitter.com/andrewstwrt">Andrew Stewart</a> has graciously written a C version of this program.  Like he
<a href="https://twitter.com/andrewstwrt/status/261282584263286784">said</a>, you should do all of your scripting in C.</p>

<pre><code class="language-c">// script.c

#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void) {
    static const char filename[] = &quot;file&quot;;
    FILE *file = fopen(filename, &quot;r&quot;);

    if (file != NULL) {
        char line[1024];
        while(fgets(line, sizeof line, file) != NULL) {
        line[strcspn (line, &quot;\n&quot;)] = '\0';

        int lengthOfLine = strlen(line);
        int word = 0;
        int i;

        for (i = 0; i &lt; lengthOfLine; i++) {
            if (isalpha(line[i])) {
            if (!word) {
                line[i] = (char) toupper (line[i]);
                word = 1;
            }
            } else {
            word = 0;
            }
        }

        printf (&quot;%s\n&quot;, line);
        }

        fclose(file);
    } else {
        perror(filename);
    }

    return 0;
}
</code></pre>

<p>Compile and run this with:</p>

<pre><code class="language-nil">$ gcc -o script script.c
$ time ./script &gt; /dev/null
</code></pre>

<p>Of course, this is ripping fast.  It takes about 1 second (1.05-1.15, never
below 1).</p>

<h2 id="recap">Recap</h2>

<pre><code class="language-nil">Haskell - String              17s
Haskell - Text                60s
Haskell - Text (Lazy)         27s
Haskell - ByteString          27s
Haskell - ByteString (Lazy)   10s
Haskell - Text, scanl (Lazy)  8.5s
Haskell - ByteString, scanl   3.5s

Python -                      6s
Python - One line, titl()     2s

Javascript &amp; V8               4.5s

Go                            2s

C                             1s
</code></pre>

<p>Not sure if I want to continue learning Haskell after this.</p>

</article>

<p class="article_date date">
  This article was first published on October 24, 2012.  As you can see, there
  are no comments.  I invite you to email me with your comments, criticisms,
  and other suggestions.  Even better, write your own article as a response.
  Blogging is awesome.
</p>


    </div>

</body>
</html>
