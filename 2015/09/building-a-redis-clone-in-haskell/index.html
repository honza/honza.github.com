<!doctype html lang="en">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="description" content="Thoughts of an open source developer with a theology degree. Honza Pokorny is a web developer and an armchair theologian in Halifax, Canada" >
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>Building a Redis clone in Haskell | Honza Pokorny</title>
  <link href="https://fonts.googleapis.com/css?family=Karla:400,400i|Montserrat:700&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="https://honza.ca/css/index.css">
  <link rel="alternate" type="application/rss+xml" href="" title="Honza Pokorny">
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-4330851-12']);
        _gaq.push(['_trackPageview']);

        (function(){
         var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
         ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
         var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();

    </script>

</head>
<body>
        <div id="banner" class="container">
          <h1><a href="/">Honza Pokorny</a></h1>
          <p><em>Thoughts of an open source developer with a theology degree</em></p>
        </div>

    <div id="wrap">

<div class="single-header">
  <h1>Building a Redis clone in Haskell</h1>

</div>

<article>
  

<p>In this post, we will attempt to make a simplified clone of <a href="http://redis.io">Redis</a> in Haskell.
Here is a set of requirements that we will aim to fullfill:</p>

<h3 id="get-and-set-operations"><code>get</code> and <code>set</code> operations</h3>

<h3 id="multi-threaded">Multi-threaded</h3>

<h3 id="atomic">Atomic</h3>

<h3 id="redis-compatible--implement-the-redis-protocol">Redis compatible (implement the Redis protocol)</h3>

<p>We should be able to use the <code>redis-cli</code> tool to connect to our server and
issue commands to it.</p>

<p>We are going to omit many features that Redis has.  For example, there will be
no disk persistence.  We will accomplish this with about 100 lines of Haskell.</p>

<h2 id="getting-started-stack">Getting started: stack</h2>

<p>We are going to use <a href="https://github.com/commercialhaskell/stack">stack</a> to build our project.  Stack is a new build tool for
Haskell projects.  We can also use it to create all the necessary files that
make up a Haskell project.  You can find the installation <a href="https://github.com/commercialhaskell/stack/wiki/Downloads">instructions</a> here.</p>

<p>Let&rsquo;s create our project.  We will call our server <em>Redish</em>.</p>

<pre><code class="language-nil">$ stack new Redish simple
</code></pre>

<p>This will create a directory <code>Redish/</code> with a few files in it.</p>

<pre><code class="language-nil">Redish/
    LICENSE
    README.md
    Redish.cabal
    Setup.hs
    src/
        Main.hs
    stack.yaml
</code></pre>

<p>You can use stack to build this project and run it:</p>

<pre><code class="language-nil">$ stack build
Redish-0.1.0.0: configure
Configuring Redish-0.1.0.0...
Redish-0.1.0.0: build
Preprocessing executable 'Redish' for Redish-0.1.0.0...
[1 of 1] Compiling Main             ( src/Main.hs, .stack-work/dist/x86_64-osx/Cabal-1.22.4.0/build/Redish/Redish-tmp/Main.o )
Linking .stack-work/dist/x86_64-osx/Cabal-1.22.4.0/build/Redish/Redish ...
Reidhs-0.1.0.0: install
Installing executable(s) in
/Users/&lt;user&gt;/&lt;dirs&gt;/Redish/.stack-work/install/x86_64-osx/lts-3.2/7.10.2/bin
$ stack exec Redish
hello world
</code></pre>

<h2 id="types">Types</h2>

<p>Let&rsquo;s start by defining our types.  Redish is an in-memory database so we will
need a representation of our database.  For a simple key-value store, all that
we need is a simple map.  Let&rsquo;s create a few aliases.</p>

<pre><code class="language-haskell">type Value = ByteString
type Key   = ByteString
type DB    = Map Key Value
</code></pre>

<p>Next, we will need to represent the commands that our server knows how to
handle.  The command data structure can be a <code>get</code>, a <code>set</code> or unknown.</p>

<pre><code class="language-haskell">data Command = Get Key
             | Set Key Value
             | Unknown
             deriving (Eq, Show)
</code></pre>

<h2 id="software-transactional-memory">Software transactional memory</h2>

<p>Now that we have our types in places, we need to write a few functions to
operate on them.  We need a way to insert data and to query our database.</p>

<p>First things first though.  Since by default everything in Haskell is immutable,
how can we change the value of our in-memory database?  We can&rsquo;t simply
overwrite the old value with the new one.  The compiler won&rsquo;t let us.  The
answer is software transactional memory, or STM for short.</p>

<p>STM allows us to atomically change a value in our program.  The atomic part is
important.  Many parts of the code can update this value and we have no way of
knowing when and how often they might do so.  STM allows us to perform atomic
updates.  This way any updates to our database will be run sequence even when
coming from different threads.  The only cost is that we have to perform any
updates within the context of <code>IO</code>.</p>

<p>Our <code>DB</code> type will be become <code>TVar DB</code>.  The <code>TVar</code> type represents the
mutable reference.  Next, let&rsquo;s create the initial value in the <code>main</code>
function:</p>

<pre><code class="language-haskell">main :: IO ()
main = do
    database &lt;- atomically $ newTVar $ fromList [(&quot;__version__&quot;, &quot;0.1.0&quot;)]
</code></pre>

<p>This will create a <code>Map</code> with a key of <code>__version__</code> which has the value
<code>0.1.0</code>.  Then, it wraps that <code>Map</code> in a <code>TVar</code> and atomically assigns it
to the <code>database</code> variable.  Each time we want to write or read the
<code>database</code> value, we have to use <code>IO</code>.  Let&rsquo;s create a helper for atomically
reading this value:</p>

<pre><code class="language-haskell">atomRead :: TVar a -&gt; IO a
atomRead = atomically . readTVar
</code></pre>

<p>And let&rsquo;s make a function to update a value in the database.  This takes a
function that does the updating and runs it through the STM machinery.</p>

<pre><code class="language-haskell">updateValue :: (DB -&gt; DB) -&gt; TVar DB -&gt; IO ()
updateValue fn x = atomically $ modifyTVar x fn
</code></pre>

<h2 id="reply-parsing">Reply parsing</h2>

<p>Next, let&rsquo;s talk about the Redis protocol.  It&rsquo;s a simple TCP scheme that looks
like this:</p>

<pre><code class="language-nil">*2\r\n$3\r\nget\r\n$4\r\nname
</code></pre>

<p>It&rsquo;s a bunch of keywords and arguments separated by newlines.  If we clean it up
and break each thing to its own line, we get:</p>

<pre><code class="language-nil">*2
$3
get
$4
name
</code></pre>

<p>Let&rsquo;s look at each line.  <code>*2</code> says to expect a command that has two
arguments.  <code>$3</code> says that the first argument is three characters long.
<code>get</code> is the three-character argument from above.  <code>$4</code> is the length of the
second argument, and <code>name</code> is the value of the second argument.  If you&rsquo;re in
the REPL provided by <code>redis-cli</code>, and you type <code>get name</code>, Redis will
translate those two words into the above representation.  A <code>set</code> command
would look like this:</p>

<pre><code class="language-nil">*3
$3
set
$4
name
$5
honza
</code></pre>

<p>This is what will be sent when you run <code>set name honza</code>.</p>

<p>This multi-argument message is called <em>multibulk</em> in the Redis documentation.
There are two other data types that Redis uses that will interest us: the OK and
the error.</p>

<p>When Redis needs to tell you that it accepted request and everything went
smoothly, it simply responds with <code>+OK</code>.  When Redis needs to indicate an
error, it replies with <code>-ERR something went wrong</code> (where &ldquo;something went
wrong&rdquo; is the message).</p>

<p>This format is very simple and actually very effective.  When we listen on a
socket for incoming messages, we have a look at the very first character.  <code>+</code>
tells us that it&rsquo;s OK, <code>-</code> signals and error, and <code>*</code> tells us to keep
reading for commands.  We incrementally read from the socket only as much data
as the protocol tells us.</p>

<p>In this section, we will write a parser for multibulk messages.  We will use the
amazing attoparsec library for this.</p>

<blockquote>
<p>The following code is heavily influenced by the <a href="https://github.com/informatikr/hedis">Hedis</a> library.  Credit goes
to Falko Peters.  Thanks!</p>
</blockquote>

<p>A multibulk message is called a <em>reply</em> in Redis lingo.  Let&rsquo;s make a type for it.</p>

<pre><code class="language-haskell">data Reply = Bulk (Maybe ByteString)
           | MultiBulk (Maybe [Reply])
           deriving (Eq, Show)
</code></pre>

<p>A <code>Bulk</code> reply is a simple string like <code>get</code> or <code>name</code> above.
<code>MultiBulk</code> is the whole message.  Let&rsquo;s also write a function that attempts
to convert a <code>Reply</code> to a <code>Command</code>.</p>

<pre><code class="language-haskell">parseReply :: Reply -&gt; Maybe Command
parseReply (MultiBulk (Just xs)) =
  case xs of
    [Bulk (Just &quot;get&quot;), Bulk (Just a)]                -&gt; Just $ Get a
    [Bulk (Just &quot;set&quot;), Bulk (Just a), Bulk (Just b)] -&gt; Just $ Set a b
    _                                                 -&gt; Just Unknown
parseReply _ = Nothing
</code></pre>

<p>Next, let&rsquo;s use attoparsec to write a parser for the <code>Reply</code> data type.</p>

<pre><code class="language-haskell">replyParser :: Parser Reply
replyParser = choice [bulk, multiBulk]
</code></pre>

<p>Our <code>replyParser</code> will try to match either a <code>bulk</code> or a <code>multiBulk</code>.
Let&rsquo;s implement those:</p>

<pre><code class="language-haskell">bulk :: Parser Reply
bulk = Bulk &lt;$&gt; do
    len &lt;- char '$' *&gt; signed decimal &lt;* endOfLine
    if len &lt; 0
        then return Nothing
        else Just &lt;$&gt; take len &lt;* endOfLine

multiBulk :: Parser Reply
multiBulk = MultiBulk &lt;$&gt; do
    len &lt;- char '*' *&gt; signed decimal &lt;* endOfLine
    if len &lt; 0
        then return Nothing
        else Just &lt;$&gt; count len replyParser
</code></pre>

<p>First, the parsers look at the first character to see what kind of message it
is.  If it starts with a <code>$</code>, it&rsquo;s a bulk.  If it starts with a <code>*</code>, it&rsquo;s
multibulk.  Then, it reads as many characters from the input as the length
indicator said.  In the case of multibulk, it recurses because it can contain
bulk messages.</p>

<p>You can now run:</p>

<pre><code class="language-haskell">&gt; parse replyParser &quot;*2\r\n$3\r\nget\r\n$4\r\nname\r\n&quot;
&gt; (MultiBulk (Just [(Bulk (Just &quot;get&quot;)), (Bulk (Just &quot;name&quot;))]))
</code></pre>

<h2 id="networking">Networking</h2>

<p>At this point, we have our data structures ready and we know how to parse
incoming requests into them.  Now we need to work on the networking part.  Let&rsquo;s
teach our program how to listen on a socket and parse incoming text into
something useful.</p>

<p>Let&rsquo;s change our <code>main</code> function to this:</p>

<pre><code class="language-haskell">main :: IO ()
main = withSocketsDo $ do
    database &lt;- atomically $ newTVar $ fromList [(&quot;__version__&quot;, version)]
    sock &lt;- listenOn $ PortNumber 7777
    putStrLn &quot;Listening on localhost 7777&quot;
    sockHandler sock database
</code></pre>

<p>This is pretty straight-forward.  Ask for a socket and then listen on it.  When
something happens on the socket, run the function <code>socketHandler</code>.  Let&rsquo;s
implement that next:</p>

<pre><code class="language-haskell">sockHandler :: Socket -&gt; TVar DB -&gt; IO ()
sockHandler sock db = do
    (handle, _, _) &lt;- accept sock
    hSetBuffering handle NoBuffering
    hSetBinaryMode handle True
    _ &lt;- forkIO $ commandProcessor handle db
    sockHandler sock db
</code></pre>

<p>Given a socket and a reference to a mutable database, we can get a handle and
start processing requests.  For each new connection, run <code>forkIO</code> which will
do all this work of parsing and responding on a new lightweight thread.  At the
end, we simply recurse to accept new work.  The <code>commandProcessor</code> function
does the heavy lifting here, so let&rsquo;s write that next.</p>

<pre><code class="language-haskell">commandProcessor :: Handle -&gt; TVar DB -&gt; IO ()
commandProcessor handle db = do
    reply &lt;- hGetReplies handle replyParser
    let command = parseReply reply
    runCommand handle command db
    commandProcessor handle db
</code></pre>

<p>This function runs the <code>replyParser</code> we wrote earlier.  It uses a very clever
function called <code>hGetReplies</code> which we will look at in a minute.  It will read
as much data as necessary from the handle to get an instance of <code>Reply</code>.  We
then convert that reply to a command and run it.</p>

<pre><code class="language-haskell">hGetReplies :: Handle -&gt; Parser a -&gt; IO a
hGetReplies h parser = go S.empty
  where
    go rest = do
        parseResult &lt;- parseWith readMore parser rest
        case parseResult of
            Fail _ _ s   -&gt; error s
            Partial{}    -&gt; error &quot;error: partial&quot;
            Done _ r     -&gt; return r

    readMore = S.hGetSome h (4*1024)
</code></pre>

<p>The <code>parseWith</code> function does partial matching.  When it can&rsquo;t parse anything,
it will use the <code>readMore</code> function to get more data and try again.  The
<code>readMore</code> function uses the handle to read more data.  Once the parser can
match something, we are done.</p>

<h2 id="running-commands">Running commands</h2>

<p>Once we have a command, we can run it!</p>

<pre><code class="language-haskell">runCommand :: Handle -&gt; Maybe Command -&gt; TVar DB -&gt; IO ()
runCommand handle (Just (Get key)) db = do
    m &lt;- atomRead db
    let value = getValue m key
    S.hPutStr handle $ S.concat [&quot;$&quot;, valLength value, crlf, value, crlf]
        where
            valLength :: Value -&gt; ByteString
            valLength = pack . show . S.length
runCommand handle (Just (Set key value)) db = do
    updateValue (insert key value) db
    S.hPutStr handle ok
runCommand handle (Just Unknown) _ =
    S.hPutStr handle $ S.concat [&quot;-ERR &quot;, &quot;unknown command&quot;, crlf]
runCommand _ Nothing _ = return ()
</code></pre>

<p>When the command is a <code>get</code>, we read the <code>DB</code> atom.  Then we construct a
bulk reply and write it to the handle.  The bulk reply is in the same format as
our messages above: <code>$5\r\nhonza\r\n</code>.  The <code>getValue</code> function is a lookup
function that returns &ldquo;null&rdquo; if a value can&rsquo;t be found.</p>

<pre><code class="language-haskell">getValue :: DB -&gt; Key -&gt; Value
getValue db k = findWithDefault &quot;null&quot; k db
</code></pre>

<p>When the command is a <code>set</code>, we use our <code>updateValue</code> function from above
and write the <code>ok</code> to the handle.  The <code>ok</code> variable is just <code>+OK\r\n</code>.</p>

<p>When the command is unknown, we write an error to the handle.</p>

<h2 id="compiling-and-running">Compiling and running</h2>

<p>You can now build your program with</p>

<pre><code class="language-nil">$ stack build
</code></pre>

<p>And run it with</p>

<pre><code class="language-nil">$ stack exec Redish
Listening on localhost 7777
</code></pre>

<p>To test it out, you can connect to it with the <code>redis-cli</code> tool:</p>

<pre><code class="language-nil">$ redis-cli -p 7777
127.0.0.1:7777&gt; set name honza
OK
127.0.0.1:7777&gt; get name
&quot;honza&quot;
</code></pre>

<p>You can test the performance with something silly, like:</p>

<pre><code class="language-nil">$ time redis-cli -r 10000 get name
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>You can see the finished product on <a href="https://github.com/honza/redish">GitHub</a>.  Feedback is welcome, so are
questions.</p>

</article>

<p class="article_date date">
  This article was first published on September 3, 2015.  As you can see, there
  are no comments.  I invite you to email me with your comments, criticisms,
  and other suggestions.  Even better, write your own article as a response.
  Blogging is awesome.
</p>


    </div>

</body>
</html>
